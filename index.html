<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>ECE 4760: Happy Little Mixer</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/header-features.css" rel="stylesheet">


</head>

<body id="page-top">

  <!-- Navigation 
<nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
      <a class="navbar-brand" href="#">ECE 5725: COOPY</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home
              <span class="sr-only">(current)</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#intro">Introduction</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#design">Design/Testing</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#results">Results</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#future">Future Work</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#references">References</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>-->

  <!-- Carousel Header -->
  <header>
    <div id="carouselExampleIndicators" class="carousel slide" data-ride="carousel">
      <ol class="carousel-indicators">
        <li data-target="#carouselExampleIndicators" data-slide-to="0" class="active"></li>
        <li data-target="#carouselExampleIndicators" data-slide-to="1"></li>
        <li data-target="#carouselExampleIndicators" data-slide-to="2"></li>
      </ol>
      <div class="carousel-inner" role="listbox">
        <!-- Slide One -->
        <div class="carousel-item active" style="background-image: url(images/fullsystem.jpg)">
          <div class="carousel-caption d-none d-md-block">
            <!--<h3 class="display-4">First Slide</h3>
            <p class="lead">This is a description for the first slide.</p>-->
          </div>
        </div>
        <!-- Slide Two -->
        <div class="carousel-item" style="background-image: url(images/hands.png)">
        </div>
        <!-- Slide Three -->
        <div class="carousel-item" style="background-image: url(images/swatches.jpg)"></div>
      </div>
    </div>
    <a class="carousel-control-prev" href="#carouselExampleIndicators" role="button" data-slide="prev">
      <span class="carousel-control-prev-icon" aria-hidden="true"></span>
      <span class="sr-only">Previous</span>
    </a>
    <a class="carousel-control-next" href="#carouselExampleIndicators" role="button" data-slide="next">
      <span class="carousel-control-next-icon" aria-hidden="true"></span>
      <span class="sr-only">Next</span>
    </a>
    </div>
  </header>

  <header class="bg-light">
    <div class="container text-center">
      <h7>Henri Clarke (hxc2), Michael Rivera (mr858), Priya Kattappurath (psk92)<br>
        ECE 4760 Final Project<br>
        Fall 2019 (12/13/19)</h7>
      <p class="lead"></p>
    </div>
  </header>

  <section id="introduction">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">

          <p class="lead">
            <center>
              <h1>Happy Little Mixer</h1>
            </center>

            <h2>Introduction</h2>
            The Happy Little Mixer is an automatic ink mixer which accepts
            either a hex user input and creates that color by measuring out
            cyan, magenta, yellow, and black (CMYK) ink. It includes open-loop
            feedback using a color sensor to correct the generated color, making
            it as accurate as possible.

          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="design">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <p class="lead">
            <h2>High Level Design</h2>

            We wanted to create something that would spark joy in a user and
            could be fun and interactive. Ideally, an ink mixer could be used
            to help teach young artists how to mix colors, as well as the
            principles of hue and saturation. It could also make the process of
            creating specific colors easier, particularly for colorblind
            artists. We called it a “happy little mixer” because we were
            inspired by the well known phrase, “happy little trees,” used by
            Bob Ross on his show “Joy of Painting.”

            <br><br>

            <h4>Logical Structure</h4>

            <img src="images/logicalstructure.png" alt="System diagram" style="width:600px;">

            <br>
            Above is a general flow diagram of the system we provided for our
            demo. The system will initially waits for a serial hex input from
            the user and then convert it to CMYK values. With these values, we
            determine how long each servo should dispense its corresponding
            color. The system then waits for the user to indicate over serial
            whether to make a color adjustment or return to the beginning. If
            the user wants to make an adjustment, we prompt the to hold a
            sample up to the color sensor for a more accurate reading and then
            wait for the user to indicate they are ready. Once ready, the
            system requests color data from an arduino attached to the color
            sensor. The system then performs a similar conversion with the
            color sensor data and compares the observed CMYK values with the
            expected values. The user is prompted again if they would like to
            make a color correction. If yes, then the system will attempt to
            modify the saturation of the appropriate channels.

            <br><br>

            <h4>Hardware and Software Tradeoffs</h4>

            Initially, our plan was to create a paint mixer, but the viscosity
            of the paint introduced mechanical issues that we couldn’t figure
            out in the given time, with the given budget. Consequently, we
            opted to use printer ink mixed with water to create dyes.
            Although this solved our initial budget issues, we encountered
            issues with secure closing mechanisms and leaks. We were also
            unable to implement closed loop feedback, because the color of dye
            in liquid form greatly differs to its color on paper.

            <br><br>

            On the software end, to reduce the complexity of our code, we
            decided to run our servos off a singular timer with four different
            output compare units using it as a source. This required that the
            corresponding duty cycle for each servo be calibrated not only for
            that specific servo, but also relative to the other servos due to
            their unique 20ms hold-off requirement.

            <br><br>

            <h4>Background Information</h4>
            We used some basic arithmetic in the use for color conversion --
            from hex, to RGB, to CMYK -- and scaling those results for output.
            We also used basic arithmetic for error calculations for the
            feedback system.
            <br><br>
            It should be noted that for CMYK colors, only two of the CMY
            values are ever nonzero at any time unless you are working with a
            grayscale value. Additionally, we had to modify the provided
            protothreads header file, pt_1_3_3.h, as it had not defined the
            auxiliary term buffer, which we needed to receive values from the
            Arduino.
            <br><br>
            To our knowledge, there are no patents for a similar product,
            although there are programs that do
            <a href="https://trycolors.com/">virtual color mixing</a>.
            We did not reference these in our development process.
            <br><br>
            This project complies with industry standards.

          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="hardware">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <p class="lead">
            <h2>Hardware Design</h2>

            Our initial mechanical design differed from our final design.
            This was because we changed our mind in deciding to use servos to
            clamp the surgical tubing after we were in the process of printing
            the already designed structure, and we decided to prioritize the
            technical aspects of our project rather than spending time redoing
            the external structure. We worked modularly and only assembled the
            entire project in the final week.
            <br><br>
            When we began to design the outer casing for our color mixer,
            we knew we needed a place for the CMYK inks, servos, and places to
            route the servo wires and the tubing. Keeping these ideas in mind,
            we created a 3D model of our proposed casing, which included levels
            to hold the ink and servos, holes to route the tubing, and slits for
            wires. In order to print the casing in a reasonable amount of time,
            we split the design into three sections.
            <center>
              <img src="images/casing.png" alt="Casing" style="width:600px;">
              <br>
              Screenshot of casing, designed with Fusion.</center>

            <br><br>
            This proved very useful, as
            we were able to modify our original design by rearranging the 3 pieces
            to be better suited to hold the servos and tubing. We also added wooden
            spacers, which gave us more vertical space so the tubing could fully
            extend. Also, instead of using the premade holes in the casing only
            for tubing, we used them to hold the servos, and later drilled extra
            holes for the tubing.
            <br><br>

            We cut our [length] of tubing into four pieces. First, we tested to
            ensure that the servos were capable of pinching the tubing shut.
            After we determined the correct calibration, we drilled holes into
            the 3D print to make space for the tubing and added the servos.
            <br><br>
            <center>
              <img src="images/newservotop.jpg" alt="Top" style="width:400px;">
              <br>
              <img src="images/newservobottom.jpg" alt="bottom" style="width:400px;">
              <br>
              Servos and tubing newly added, top and bottom.</center>
            <br><br>
            We added wooden spacers to allow the servos to move without hitting
            the wall of the structure, then hot glued the next layer on. We
            threaded the tubing through the top holes and used hot glue to secure
            them in place and create a waterproof layer.
            <br><br>
            <center>
              <img src="images/spacers.jpg" alt="Spacers" style="width:600px;">
              <br>
              Spacers added to elevate top level away from servos.</center>
            <br><br>
            Next, we drilled holes into the bottom of the plastic bottles to be
            slightly wider than the tubing. We then placed hot glue around the
            tubing and slipping the plastic bottle on, then added additional hot
            glue to create a water seal. We tested this with water to ensure that
            there was no leakage, and that the servos were still capable of
            clamping the tubing properly.

            <br><br>
            <center>
              <img src="images/bottles.jpg" alt="Bottles" style="width:400px;">
              <br>
              Reservoirs of ink sealed off using hot glue.</center>

            <br><br>
            The servos were too low for a cup to fit under, so we sawed some
            stilts from a scrap block of wood and glued them in for the
            appropriate height. We also trimmed the tubing to ensure that they
            wouldn’t get contaminated in the already mixed dye.
            <br><br>
            <center>
              <img src="images/stilts.jpg" alt="stilts" style="width:400px;">
              <br>
              Stilts added to elevate everything from bottom level. Support in the back not shown.</center>
            <br><br>
            In retrospect, we could have done it more elegantly, but we did not
            lay out our mechanical setup rigorously enough at the beginning and were
            too pressed for time to redo it. In addition, the size of our 3D
            printed pieces were limited by the upper limits of the 3D printer.
            Despite these challenges, our final product was functional.


          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="hardware">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <p class="lead">
            <h4>Small Board</h4>
            To mount the PIC32 for this project, we utilized a Small Board
            designed by Sean Carroll. The Small Board is a breakout carrier for
            the PIC32. Our motivation for using this was primarily budget
            constraints while maintaining the familiarity of a breakout board
            similar to the one we had used for the previous labs in this class.
            <br><br>
            <center>
              <img src="images/smallboard.png" alt="Casing" style="width:600px;">
              <br>
              Sean Carroll's small board.</center>

            <br><br>

            More on the small board can be found on the <a
              href="https://people.ece.cornell.edu/land/courses/ece4760/PIC32/target_board.html">class webpage.</a>

            <br><br>

            <h4>Parallax Standard Servos</h4>
            Our initial plans for this project were to either use motor
            controlled syringes or peristaltic pumps to dispense paint.
            However, due to mechanical complexity and budget constraints
            respectively, we settle on a gravity based system with surgical
            tubing and servos to clamp them shut. We used standard servos
            ecause they were readily available at the time courtesy of Joe
            Skovira.
            <br>
            <br>

            <center>
              <img src="images/servo_wiring.png" alt="Casing" style="width:600px;">
              <br>
              Servo wiring, from <a
                href="https://www.parallax.com/sites/default/files/downloads/900-00005-Standard-Servo-Product-Documentation-v2.2.pdf">datasheet.</a>
            </center>
            <center>
              <img src="images/servo_timing.png" alt="Casing" style="width:600px;">
              <br>
              Servo timing, from <a
                href="https://www.parallax.com/sites/default/files/downloads/900-00005-Standard-Servo-Product-Documentation-v2.2.pdf">datasheet</a>.
            </center>


            <br><br>
            Above are the wiring and timing schemes for the servos from their
            datasheet. The servos have a power requirement of 4 to 6V and an
            I/O input range of 3.3 to 5V. The required PWM timing is that pulse
            widths should be between 0.75ms and 2.25ms, and pulses should be
            separated by 20ms.

            <br><br>
            <h4>Color Sensor + Arduino</h4>

            We used the color sensor <a href="https://www.adafruit.com/product/1334">TCS34725.</a>
            <br><br>
            Other than the normal wiring of the Color Sensor (which is in the
            circuit diagram for the project), we also needed to add additional
            circuitry between the Arduino transmit pin (pin 1) and the receive
            pin on the PIC32 (PIN RB13). This is because the Arduino runs on 5V
            power, and the PIC32 runs on 3.3V. Therefore, we needed to add a low
            pass filter between these two pins, in order to make sure the PIC32
            wasn’t overloaded.

          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="software">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <p class="lead">
            <h2>Software Design</h2>
            <h4>CMYK Conversion</h4>
            RGB values are colors defined by the amounts of red, green, and blue
            light they contain. CMYK values are colors defined by the amounts of
            cyan, magenta, yellow, and black pigment they contain. We used the
            CMY primary colors because we were mixing pigment, and we decided to
            allow the user to pick a HEX value -- which are simply RGB values
            strung together in hexadecimal to make a 6-digit string -- because
            it would be an easier format for a user to enter. Thus, we needed to
            convert from HEX to CMYK.
            <br><br>

            <center>
              <img src="images/cmyk.png" alt="Casing" style="width:300px;">
              <br>
              <a href="https://99designs.com/blog/tips/correct-file-formats-rgb-and-cmyk/">Source</a></center>

            <br><br>
            Very coincidentally, someone had already written a <a
              href="http://www.javascripter.net/faq/hex2cmyk.htm">HEX to CMYK
              conversion in JavaScript. </a>We used its logic to write our own HEX
            to CMYK conversion in C. Our conversion took a HEX code as character
            array of length 6, pulled the RGB values from it, then converted
            those according to the referenced code.


            <br><br>
            <h4>Color Sensing</h4>
            The TCS34725 came with its own arduino source code and library.
            Here is a link to the <a href="https://github.com/adafruit/Adafruit_TCS34725"> original github repo.</a>
            In this code, we took the example tcs34725.ino, renamed it COLORSENSOR.ino, and modified it to fit our
            needs. <br><br>
            The original code got the raw RGB values and also some extra
            calculations such as color temperature, which we removed.
            The color sensor raw outputs range from 0-65535. In order to make
            them usable RGB values, we divided the raw value by 256 to scale it
            to 0-255. However, this number usually ended up fairly small within
            the 0-255 range (generally under 30), so multiplied it by 10.
            Sometimes the “multiply by 10” put the value above 255.
            In this case, we did a second scale to the RGB values so the
            highest one is 255 and the rest are scaled down accordingly.
            <br><br>
            Once we had usable RGB values between 0-255, we converted the values
            float to integer. This integer was compared to the previous RGB
            values, which were saved in global variables. If the value is the
            same as the previous value, it will then convert those integer RGB
            values to hex and then put them into strings, which are concatenated
            and then sent serially to the PIC. If the values do not match the
            global variables, we set the current values to the global variables
            and begin the scan again. The requirement for the values to be
            matched allows for greater accuracy in which color is output.
            <br><br>
            <h4>PWM and Servo Control</h4>
            For this project, we utilized a singular timer with four different output compare units using it as a
            source. The four output compare units were wired to RB9, RB5, RB2, and RA2, each generating a PWM signal for
            a different servo. Servos were initialized to a closed state based on how they had been mounted. Once ready
            to dispense the dye, we used the values from the CMYK conversion as timing for how long each servo should be
            open. We scaled the values, so the maximum time a servo could be open was one second and the minimum was ten
            milliseconds. To have each servo remain in a given position, we found that setting the corresponding duty
            cycle to zero worked. We were then able to target each servo individually, modifying the period and
            corresponding duty cycle. We created the timings by having the servo thread yield for the specified time as
            shown below.
            <br>

            <pre>
              generate_period2 = (int)(((20.0 + 0.85) / 32.0) * 40000);
              pwm_on_time3 = (int)((0.85 / 32.0) * 40000);
              WritePeriod2(generate_period2);
              SetDCOC3PWM(pwm_on_time3);
              PT_YIELD_TIME_msec(10*error_m);
            </pre>

            Additionally, to have the timer count for larger intervals, we
            increased the prescaler in the timer declaration.

            <pre>
              OpenTimer2(T2_ON | T2_SOURCE_INT | T2_PS_1_32, generate_period2);
            </pre>

            <h4>Serial Communication</h4>

            In order to implement two lines of serial communication on the PIC --
            one to the computer for user input, and one to the Arduino to read the
            color sensor values -- we referenced the instructions on <a
              href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">the class webpage.</a>

            Using Protothreads 1.3.3, we used the main serial channel to communicate with the PC and the auxiliary
            serial channel to communicate with the Arduino. For the serial PC communication, we used a UART to USB
            serial cable, connecting RA1 to RX, RB10 to TX, and grounding both. Similarly, for the arduino, we connected
            RB13 to the arduino RX and RB7 to the arduino TX.

            To transmit and receive from the PIC32, we used the serial buffers for the main and auxiliary channels. To
            write, using the main as an example:
            <br><br>
            <code>sprintf(PT_send_buffer, “hex #”);
            PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output));</code>
            <br><br>
            To read, using auxiliary as an example:
            <br><br>
            <code>PT_SPAWN(pt, &pt_input_aux, PT_GetSerialBuffer_aux(&pt_input_aux));
            sscanf(PT_term_buffer_aux, “%s”, &hex_value);</code>
            <br><br>
            Please note that <code>PT_term_buffer_aux</code> is not originally defined in <code>pt_1_3_3.h.</code> This
            is something we defined
            based off of how <code></code>PT_term_buffer</code> was written.

            <br><br>
            <h4>Feedback Control</h4>
            We opted to do user prompted feedback control due to the inconsistency
            of the color sensor. By prompting users if (1) they wanted to adjust t
            he color and (2) to hold a sample up to the color sensor, we could
            obtain a more accurate reading without having to handle the color
            sensor being splashed (if we had placed the sensor close to the
            mixture) and reflectance of the color sensor’s LED (if we had used
            a clear container for the mixture).

            <br><br>
            To perform feedback, we wrote a simple ready/request protocol, where
            the Arduino would initialize and waiting for a request from the
            PIC32. When a user requested a color adjustment, we would then write
            a request to the auxiliary serial buffer and then wait for Arduino.
            The Arduino would then read to color sensor, convert the value to hex,
            and write that to the serial buffer before going back to its ready state.
            The PIC32 would then use HEX to CMYK conversion and compare the sensor
            values with the expected color values.

            <br><br>
            We again prompted the user, displaying both the observed and expected
            values, asking the user if they wanted to proceed with an adjustment.
            If yes, then we observed which of the expected color channels (CMY)
            were zero, because at most two are nonzero at any one time, and
            calculated additive adjustments for the nonzero channels as shown below.
            For the black channel, we only checked if the observed color was too
            bright, and then added more pigment if so. We then used the adjustment
            values to control the servo timings to dispense the appropriate amount
            of pigment for the adjustment.
            <br><br>
            <pre>
              if(final_c &lt; 5){ 
                if(y2 &lt; final_y){
                  error_y = final_y - y2;
                  }
                if(m2 &lt; final_m){
                  error_m=final_m - m2;
                }
              }
            </pre>

            <br><br>

            <h4>Aside: Color Sensor as Input</h4>
            Although this did not make our final demo code due to time
            constraints, we did write code to use the color sensor as an input
            option in addition to the terminal hex value. The idea behind this
            was to be able to replicate the colors of specific objects. The code
            functioned similarly to the user prompted feedback control in that
            the system would ask the user whether they would want to input a hex
            code or scan an object. This version was not included in our demo
            due to inaccuracy of the color sensor on objects with reflective
            surfaces and variable ambient lighting conditions.

          </p>
        </div>
      </div>
    </div>
  </section>
  <section id="results" class="bg-light">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <p class="lead">
            <h2>Results of Design</h2>
            The final results of the project may be seen in our demo video:
            <br>
            <center>
              <iframe width="560" height="315" src="https://www.youtube.com/embed/Y1xkPBjU8A4" frameborder="0"
                allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>
            </center>
            <br><br>
            <h4>Speed</h4>
            The servos’ response to the user’s hex input is very fast, which you
            can see here (since it was too fast to be caught in the demo):
            <br><br>
            <center>
              <iframe width="560" height="315" src="https://www.youtube.com/embed/07r_sOD8Pi0" frameborder="0"
                allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>
            </center>
            <br>
            The scanning, on the other hand, takes a variable amount of time.
            In order to maintain accuracy, the arduino will only send color data
            if the color sensor detects the same RGB values twice in a row. While
            this generally means that the scan will be accurate, it also means
            that slight physical movements of the color sensor or surrounding
            light will cause the scanning to take a longer amount of time.

            <br><br>
            <h4>Accuracy</h4>


            <table style="border:1px solid black; width:100%">
              <tr>
                <th><b>Scan: #1C4B5E</b></th>
                <th><b>C</b></th>
                <th><b>M</b></th>
                <th><b>Y</b></th>
                <th><b>K</b></th>
              </tr>
              <tr>
                <td>First Scan</td>
                <td>70</td>
                <td>20</td>
                <td>0</td>
                <td>63</td>
              </tr>
              <tr>
                <td>Feedback 1 Scan</td>
                <td>0</td>
                <td>11</td>
                <td>24</td>
                <td>82</td>
              </tr>
              <tr>
                <td>Feedback 1 Correction</td>
                <td>70</td>
                <td>9</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <td>Feedback 2 Scan</td>
                <td>12</td>
                <td>0</td>
                <td>14</td>
                <td>78</td>
              </tr>
              <tr>
                <td>Feedback 2 Correction</td>
                <td>58</td>
                <td>20</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
            For color #1C4B5E, which looks like a dark blue to the human eye, we can clearly see feedback demonstrated.
            In the color sensors’ first go, it created a color that was much too dark. In the first feedback scan, it
            noticed that there was much extra black. During the corrections, we can see that the color sensor does not
            add any more black, as there is already too much, and instead adds more cyan and magenta in order to correct
            the color.
            <br><br>
            <table style="border:1px solid black; width:100%">
              <tr>
                <th><b>Scan: <div id="FFAB00"></div></b></th>
                <th><b>C</b></th>
                <th><b>M</b></th>
                <th><b>Y</b></th>
                <th><b>K</b></th>
              </tr>
              <tr>
                <td>First Scan</td>
                <td>0</td>
                <td>32</td>
                <td>100</td>
                <td>0</td>
              </tr>
              <tr>
                <td>Feedback 1 Scan</td>
                <td>0</td>
                <td>1</td>
                <td>30</td>
                <td>43</td>
              </tr>
              <tr>
                <td>Feedback 1 Correction</td>
                <td>0</td>
                <td>31</td>
                <td>70</td>
                <td>0</td>
              </tr>
              <tr>
                <td>Feedback 2 Scan</td>
                <td>0</td>
                <td>8</td>
                <td>34</td>
                <td>57</td>
              </tr>
              <tr>
                <td>Feedback 2 Correction</td>
                <td>0</td>
                <td>24</td>
                <td>66</td>
                <td>0</td>
              </tr>
            </table>
            In the color sensors first go, the color it made was slightly too yellow, so in the first feedback it added
            more magenta to compensate and make the color more orange. It also added more yellow to make it more
            pigmented. In the second time around, while there was more yellow and magenta, there still wasn’t as much
            pigment as the original color, so the color sensor added more.
            <br><br>
            <table style="border:1px solid black; width:100%">
              <tr>
                <th><b>Scan: #BE19F0</b></th>
                <th><b>C</b></th>
                <th><b>M</b></th>
                <th><b>Y</b></th>
                <th><b>K</b></th>
              </tr>
              <tr>
                <td>First Scan</td>
                <td>20</td>
                <td>89</td>
                <td>0</td>
                <td>5</td>
              </tr>
              <tr>
                <td>Feedback 1 Scan</td>
                <td>0</td>
                <td>12</td>
                <td>13</td>
                <td>64</td>
              </tr>
              <tr>
                <td>Feedback 1 Correction</td>
                <td>20</td>
                <td>77</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <td>Feedback 2 Scan</td>
                <td>0</td>
                <td>26</td>
                <td>39</td>
                <td>90</td>
              </tr>
              <tr>
                <td>Feedback 2 Correction</td>
                <td>20</td>
                <td>63</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>

            To the naked eye, the three color swatches for this color look the same. This shows that the ratio of colors
            stayed consistent through the feedback runs. Looking at the PuTTY output, we can see that the color sensor
            was attempting to make each of the colors more saturated.
            <br><br>
            <table style="border:1px solid black; width:100%">
              <tr>
                <th><b>Scan: #19FA82</b></th>
                <th><b>C</b></th>
                <th><b>M</b></th>
                <th><b>Y</b></th>
                <th><b>K</b></th>
              </tr>
              <tr>
                <td>First Scan</td>
                <td>90</td>
                <td>0</td>
                <td>47</td>
                <td>1</td>
              </tr>
              <tr>
                <td>Feedback 1 Scan</td>
                <td>43</td>
                <td>0</td>
                <td>20</td>
                <td>60</td>
              </tr>
              <tr>
                <td>Feedback 1 Correction</td>
                <td>47</td>
                <td>0</td>
                <td>27</td>
                <td>0</td>
              </tr>
              <tr>
                <td>Feedback 2 Scan</td>
                <td>26</td>
                <td>0</td>
                <td>21</td>
                <td>43</td>
              </tr>
              <tr>
                <td>Feedback 2 Correction</td>
                <td>64</td>
                <td>0</td>
                <td>26</td>
                <td>0</td>
              </tr>
            </table>

            This is another case where the color sensor was trying to amp up the pigment during each feedback run. It is
            interesting to note in this case that it the color sensor seemed to see “less” cyan during the feedback 2
            scan than the feedback 1 scan. This may be due to the fact that the color was still slightly wet on the
            paper when we scanned it, and we may have scanned a less dense part of the color.

            <br><br>
            <h4>Safety</h4>
            Our project was safe on its own -- but a project involving lots of
            liquid in an electronics lab has the capability for mild disaster.
            In order to ensure that the liquid stayed away from electricity, we
            were careful about where we placed liquid. We always kept our project
            and any liquid in a Rubbermaid container so that any spills would be
            contained.
            <br><br>
            <h4>Usability</h4>
            Our project by nature is accessible to people with colorblindness,
            because it is not necessary to distinguish colors visually in order
            to create a certain color.
            <br><br>
            The physical design of our project is somewhat inaccessible.
            Loading and removing the cup to catch ink, filling the containers,
            and ensuring the tubes don’t splatter everywhere requires dexterity
            that some people may not have. Even with small hands, interchanging
            the cups resulted in getting ink on one’s hands. To improve this in
            future iterations, we would put more thought into the mechanical
            design to be open and secure.

          </p>
        </div>
      </div>
    </div>
  </section>


  <section id="conclusions">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">

          <p class="lead">
            <h2>Conclusions</h2>
            We were unsure that our project would actually function, as our
            initial plans changed and we ended up having to improvise a lot of
            aspects of the project. However, we were able to create an ink mixer
            that could successfully mix colors based on a hex input and respond
            successfully to open-loop feedback -- in that sense, our project met
            expectations.
            <br><br>
            We were forced to be adaptive with our design, since we initially
            proposed creating a paint mixer. However, we realized that the
            viscosity of paint presented many more mechanical challenges in
            dispensing and mixing the paint -- which were not our technical
            focus (as we were more interested in the color feedback), had a
            larger propensity for failure (due to a lot of moving parts), and
            were pushing the budget limit -- so we switched to working with inks.
            In the future, with more time to figure out a mechanical system, it
            would be fun to create a paint mixer -- but for the time given, it
            was more practical to create an ink mixer.
            <br><br>
            One issue we ran into was a lack of “true” primary colors. The inks
            we used were cheap printer inks, and their corresponding cyan, magenta,
            and yellow were not true to the actual cyan, magenta, and yellow colors.
            <br><br>

            <br><br>
            In the future, we’d like to either 1) purchase better inks or 2) somehow
            compensate for the error in our color conversion. We considered trying
            to figure out how to convert from RGB to the slightly inaccurate CMYK,
            but did not do so due to time constraints -- and our results were
            approximately correct, anyway. We’d also like to do more tests with
            more highly concentrated colors, since we watered down our inks, and
            with more absorbent paper (like watercolor paper).
            <br><br>
            We were proactive in creating a mechanical design early, with the
            hopes of filling it nicely and having a polished product. After we
            changed designs, however, we had to improvise a lot and had a somewhat
            disheveled-looking end result. If we were to do it over again, we would
            ideally have knowledge of our full design before creating the model,
            so that we could make one that actually fit our mechanical design and
            was easily usable by the user.
            <br><br>
            In a similar aesthetic vein, we would also clean up the PuTTY output
            to be more visually appealing, or perhaps create a GUI that would
            allow the user to pick their color on a visual color picker rather
            than just entering the hex code.

          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="conclusions">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">

          <p class="lead">
            <h2>Appendix A: Permissions</h2>
            The group approves this report for inclusion on the course website.
            The group approves the video for inclusion on the course Youtube channel.
            <br><br>
            <h2>Appendis B: Schematics</h2>
            <center>
              <img src="images/circuitdiagram.png" alt="Casing" style="width:600px;">
              <br>
              Overall circuit diagram.</center>
            <br><br>
            <h2>Appendix C: Budget</h2>
            <table style="border:1px solid black; width:100%">
              <tr>
                <th><b>Component</b></th>
                <th><b>Quantity</b></th>
                <th><b>Vendor</b></th>
                <th><b>Total Price</b></th>
              </tr>
              <tr>
                <td><a href="https://www.amazon.com/Macks-Lure-4-Inch-Surgical-Tubing/dp/B003OBCM4O">Tubing - 3ft.</td>
                <td>1</td>
                <td>Amazon</td>
                <td>$6.39</td>
              </tr>
              <tr>
                <td>Parallax Rotation Servos</td>
                <td>4</td>
                <td>Joe Skovira</td>
                <td>$59.96</td>
              </tr>
              <tr>
                <td>CAD</td>
                <td>1</td>
                <td>Cornell Maker Space</td>
                <td>$0</td>
              </tr>
              <tr>
                <td><a
                    href="https://www.amazon.com/HOTCOLOR-Cartridge-Refill-Cartridges-Magenta/dp/B016BF5OQM/ref=sr_1_5?keywords=cyan+magenta+yellow+dye&qid=1573093093&sr=8-5">CMYK
                    Printer Ink</a></td>
                <td>1</td>
                <td>Amazon</td>
                <td>$16.13</td>
              </tr>
              <tr>
                <td>Carry-On Containers</td>
                <td>4</td>
                <td>Amazon</td>
                <td>$5.72</td>
              </tr>
              <tr>
                <td>Sean Carroll's Small Board</td>
                <td>1</td>
                <td>Bruce Land</td>
                <td>$4</td>
              </tr>
              <tr>
                <td>White Board</td>
                <td>1</td>
                <td>Bruce Land</td>
                <td>$6</td>
              </tr>
              <tr>
                <td>Power Supply</td>
                <td>1</td>
                <td>Bruce Land</td>
                <td>$5</td>
              </tr>
              <tr>
                <td>PIC32</td>
                <td>1</td>
                <td>Bruce Land</td>
                <td>$5</td>
              </tr>
              <tr>
                <td>Sockets</td>
                <td>28</td>
                <td>Bruce Land</td>
                <td>$1.40</td>
              </tr>
              <tr>
                <td>Jumper</td>
                <td>11</td>
                <td>Bruce Land</td>
                <td>$0.10</td>
              </tr>
              <tr>
                <td>Color Sensor</td>
                <td>1</td>
                <td>Adafruit</td>
                <td>$7.95</td>
              </tr>
              <tr>
                <td>Arduino</td>
                <td>1</td>
                <td>Surplus - from Henri</td>
                <td>$0</td>
              </tr>
              <tr>
                <td><b>Total</b></td>
                <td></td>
                <td></td>
                <td><b>$118.65</b></td>
              </tr>
            </table>
            <br><br>

            <h2>Appendix D: Commented Code</h2>
            PIC32 Code:
            <li><a
                href="https://github.com/hxnri/happy-little-mixer/blob/master/code/final/Big_board_pt_1_3_3/happy_lil_mixer.c">happy_lil_mixer.c</a>
            </li>
            <li><a
                href="https://github.com/hxnri/happy-little-mixer/blob/master/code/final/Big_board_pt_1_3_3/port_expander_brl4.h">port_expander_brl4.h</a>
              - from Bruce Land</li>
            <li><a
                href="https://github.com/hxnri/happy-little-mixer/blob/master/code/final/Big_board_pt_1_3_3/config_1_3_3.h">config_1_3_3.h</a>
              - from Bruce Land, with edits </li>
            <li><a
                href="https://github.com/hxnri/happy-little-mixer/blob/master/code/final/Big_board_pt_1_3_3/pt_cornell_1_3_3.h">pt_cornell_1_3_3.h</a>
              - from Bruce Land</li>
            Arduino Code:
            <li><a
                href="https://github.com/hxnri/happy-little-mixer/blob/master/code/Adafruit_TCS34725-master/examples/COLORSENSOR/COLORSENSOR/COLORSENSOR.ino">COLORSENSOR.ino</a>
            </li>
            <br><br>
            <h2>Appendix E: Datasheets and References</h2>
            <li><a
                href="https://www.parallax.com/sites/default/files/downloads/900-00005-Standard-Servo-Product-Documentation-v2.2.pdf">Parallax
                Rotation Servo Datasheet</a></li>
            <li><a href="https://www.adafruit.com/product/1334">TCS34725 Color Sensor Datasheet</a></li>
            <li><a href="https://github.com/adafruit/Adafruit_TCS34725">TCS34725 Github</a></li>
            <li><a href="http://www.javascripter.net/faq/hex2cmyk.htm">Javascript HEX to CMYK
                conversion code </a></li>
            <li><a href="https://people.ece.cornell.edu/land/courses/ece4760/PIC32/target_board.html">ECE 4760 Board
                Reference Page</a></li>
            <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_UART.html">UART Communication
                for PIC32</a></li>
            <br><br>
            <h2>Appendix F: Work Distribution</h2>
            Although we have listed the person most responsible for a particular task, we helped each other on all
            tasks.
            <li>Brainstorming and design formation: Everybody</li>
            <li>CAD: Priya</li>
            <li>3D Printing: Michael Xiao (ECE 4760 Fa18)</li>
            <li>Servo Calibration: Michael</li>
            <li>Serial Communication: Henri and Michael</li>
            <li>Color Conversion: Henri</li>
            <li>Color Sensor Testing: Priya</li>
            <li>Feedback: Michael</li>
            <li>Mechanical Assembly: Henri</li>
            <li>Testing: Everybody</li>
            <li>Hand Dying: Priya</li>
            <li>Report: Everybody</li>
            <li>Website: Henri</li>

          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; 2019</p>
    </div>
    <!-- /.container -->
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>

</body>

</html>